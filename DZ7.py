# # 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# # который должен принимать данные (список списков) для формирования матрицы.
# # Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# # Примеры матриц вы найдете в методичке.
# # Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# # Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# #
# # Результатом сложения должна быть новая матрица.
# # Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с
# # первым элементом первой строки второй матрицы и т.д.
#
class Matrix:
    def __init__(self, matr_1, matr_2):
        self.matr_1 = matr_1
        self.matr_2 = matr_2

    def __add__(self):
        matr = [[0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]]

        for i in range(len(self.matr_1)):

            for j in range(len(self.matr_2[i])):
                matr[i][j] = self.matr_1[i][j] + self.matr_2[i][j]
        return str('\n'.join(['\t'.join([str(j) for j in i]) for i in matr]))


    def __str__(self):
        return str('\n'.join(['\t'.join([str(j) for j in i]) for i in matr]))

matrix_new = Matrix([[2, 5, 10], [4, 10, 2], [8, 7, 6]], [[5, 3, 2], [1, 9, 4], [7, 6, 10]])
#
# print(matrix_new.__add__())
# # 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# # Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# # К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# # размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# # Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# # для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# # Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# # реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

class Clothes:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def square_coat(self):
        return self.width / 6.5 + 0.5

    def square_suit(self):
        return self.height * 2 + 0.3

    @property
    def sum_textile(self):
        self.sum = round((self.width / 6.5 + 0.5) + (self.height * 2 + 0.3))
        return str(f'Расход ткани всего: {self.sum}')

class Coat(Clothes):
    def __init__(self, width, height):
        super().__init__(width, height)
        self.square_c = round(self.width / 6.5 + 0.5)

    def __str__(self):
        return f'Расход на пальто {self.square_c}'


class Suit(Clothes):
    def __init__(self, width, height):
        super().__init__(width, height)
        self.square_s = round(self.height * 2 + 0.3)

    def __str__(self):
        return f'Расход на костюм {self.square_s}'

my_close = Clothes(50, 100)
print(my_close.sum_textile)
my_coat = Coat(50, 100)
my_suit = Suit(50, 100)

print(my_coat)
print(my_suit)

print(my_coat.square_coat())
print(my_suit.square_suit())

# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное)
# деление клеток, соответственно. В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше
# нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества
# ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.

class Cell:
    def __init__(self, quantity):
        self.quantity = int(quantity)

    def __str__(self):
        return f'Ответ:  {self.quantity } - {self.quantity * "*"}'

    def __add__(self, other):
        return Cell(self.quantity + other.quantity)

    def __sub__(self, other):
        if (self.quantity - other.quantity) > 0:
            return Cell(self.quantity - other.quantity )
        else:
            return print('Меньше 0')

    def __mul__(self, other):
        return Cell(int(self.quantity * other.quantity))

    def __truediv__(self, other):
        return Cell(round(self.quantity // other.quantity))

cells1 = Cell(5)
cells2 = Cell(10)

print(f'Сложение: {cells1 + cells2}')
print(f'Вычитание: {cells2 - cells1}')
print(f'Умножение: {cells1 * cells2}')
print(f'Деление: {cells1 / cells2}')